# © Artur Czarnecki. All rights reserved.
# Intergrax framework – proprietary and confidential.
# Use, modification, or distribution without written permission is prohibited.

from __future__ import annotations

from dataclasses import dataclass, field
from datetime import datetime
from typing import Dict, List, Literal


@dataclass(frozen=True)
class MemoryOwnerRef:
    """
    Identifies who "owns" a piece of long-term memory.

    Typical patterns:
      - user-level memory:
            owner_type="user",         owner_id="<user_id>"
      - organization-level memory:
            owner_type="organization", owner_id="<org_id>"
      - global memory (shared across all contexts):
            owner_type="global",       owner_id="global"

    This indirection allows the same long-term memory mechanism
    to be reused for users, organizations and global/system-level data.
    """

    owner_type: Literal["user", "organization", "global"]
    owner_id: str


@dataclass
class LongTermMemoryItem:
    """
    A single long-term memory entry.

    This is a *compact, semantically meaningful* piece of information,
    not a raw document chunk. Examples:
      - a compressed summary of a past conversation episode,
      - a distilled fact extracted from documents,
      - a curated note manually created by a user or admin,
      - a short "insight" generated by a memory-writing agent.

    It is intentionally text-first; embeddings/vector search are handled
    by higher-level components, which index and query these items.
    """

    # Globally unique identifier of the memory item.
    # The caller is responsible for generating this (e.g. UUID4).
    item_id: str

    # Owner defines the scope of this memory (user / organization / global).
    owner: MemoryOwnerRef

    # Core semantic content of the memory.
    text: str

    # Source category of the memory item.
    # Must be one of the predefined literal values.
    source_type: Literal[
        "conversation",
        "document",
        "manual_note",
        "system",
        "ingestion",
    ] = "manual_note"

    # Optional pointer to the original source.
    # Examples:
    #   - message_id, document_id, url, file_path, session_id, etc.
    source_reference: str = ""

    # Heuristic importance score in [0.0, 1.0].
    # Higher importance items can be preferred during search or summarization.
    # Exact semantics are up to the calling code (LLM, heuristics, etc.).
    importance: float = 0.5

    # Simple tag-based classification for routing and filtering.
    # Examples:
    #   - ["project:mooff", "topic:architecture", "type:decision"]
    #   - ["health", "sibo", "lifestyle"]
    tags: List[str] = field(default_factory=list)

    # Timestamps (UTC).
    created_utc: datetime = field(default_factory=datetime.utcnow)
    last_updated_utc: datetime = field(default_factory=datetime.utcnow)
    last_accessed_utc: datetime = field(default_factory=datetime.utcnow)

    # Extensible metadata for backend-specific needs.
    # Example keys:
    #   - "session_id", "embedding_id", "doc_chunk_id",
    #   - "vectorstore_provider", etc.
    metadata: Dict[str, str] = field(default_factory=dict)

    def touch_access(self) -> None:
        """
        Update the last_accessed_utc timestamp.

        Storage implementations MAY call this automatically when an item is
        returned from read/search APIs.
        """
        self.last_accessed_utc = datetime.utcnow()

    def update_text(self, new_text: str) -> None:
        """
        Update the text of the memory item and refresh the last_updated_utc timestamp.

        This is useful if you periodically re-summarize or compact older items
        into a more concise representation.
        """
        self.text = new_text
        self.last_updated_utc = datetime.utcnow()
